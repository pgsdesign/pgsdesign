Intro to Encoding
Encodings
Endianess (sort of related to encodings)
Base58 (name of the school, used to use it a lot in btc)

new to bitfiddling

What's up with encoding and the common bitcoin ones

What is an encoding?
taking some normal information - ie want to tell someone the number 5, tell them out loud, but since computers it has to be written down, send character 5, takes up 1 space, take info like 5 or 10 and how we write that down and express it. 
the other person we want to send it to needs to decode the info so we need a shared understanding of the encoding being used
what character set is it?
weird language - Y means 5 as we are used to it.
If I didn't tell you I was using weird language you would not understand how to interpret the info
cool thing about encodings - translate between one encoding to the next so it could be "5" or "the number five"

Encode Numbers

Decimals - 10 characters, (0 1 2 3 4 5 6 7 8 9)
hexadecimals - 16 characters (0 1 2 3 4 5 6 7 8 9 A B C D E F)
binary: - 2 characters (0 1)
base58: 58 characters (123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz)
byte: ...256

hex:    0 1 2 3 4 5 6 7 8 9  A  B  C  D  E  F (16 char set)

dec:    0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 (10 char set)

bin:    0 1 (2 char set)

base58: 1

bytes: .... 256

Eleven in hex:  b
Eleven in dec: 11
Eleven in b58: 

Save space using hex

dec: 10282948  10,282,948
hex.   9ce7c4 need less space

can ask python
hex(10282948)
'0x9ce7c4'

"0x" means that the next thing is encoded in hex

4 * 16^0 + 12 * 16^1 + 7 * 16^2 + 14 * 16^3 + 12 * 16^4 + 9 * 16^5 = 10282948
4 + 192 + 1792 + 57344 + 786432 + 9437184 = 10282948

General formula to convert from any encoding to decimals (we are native speakers of) character value (look this up) * the number of characters in the encoding (hex = 16) raised to the power of the position of that character in the whole set.

character value (look this up)
times
the number of characters in the encoding (hex = 16)
raised to the power of the position of that character in the whole set

From decimal to another encoding:

10282948 % 16 = 4 - first mod by the number of characters (4 in hex)

(10282948 - 4) % 16**2 = 192 then divide by 16 to get 12 (c in hex)
10282944

(10282944 - 192) % 16**3 = 1792 then divide by 16**2 to get 7 (7 in hex)
10282752

(10282752 - 1792) % 16**4 = 57344 then divide by 16**3 to get 14 (e in hex)
10280960

(10280960 - 57344) % 16**5 = 786432 then divide by 16**4 to get 12 (c in hex)
10223616

(10223616 - 786432) % 16**6 = 9437184 then divide by 16**5 to get 9 (9 in hex)
9437184

(9437184 - 9437184) 0

9 c e 7 c 4 

when you can no longer send anymore info in a single char, now we need to send 2 chars

after 9 you have to send 10

can't fit more in 9 and we want one more so we need to add a slot.

count to 10 in binary
00000000 --> 0
11111111 --> 255      biggest number you can fit in a byte sized bucket
             0 ->  0
             1 ->  1
            10 ->  2
            11 ->  3
           100 ->  4
           101 ->  5
           110 ->  6
           111 ->  7
          1000 ->  8
          1001 ->  9
          1010 -> 10

sort of fun other encoding base58 stuff 

addresses that are public keys on mainnet always start with 1

addresses that are made from more complicated scripts start with 3

how do encodings relate to bitcoin
pre segwit

segwit - uses a different encoding called bech32

python wants the values in hex when working with base58

addr = base58.b58decode('3EVrDr2UpkLqRWza2vjyvboF5AXaqLsfD6')
addr.hex()
'058c7cf6077890b9a47744ce6326116bda102fd2b17dbe9a55'
int(addr.hex(), 16)
34830267579360635884357608966033687849564572378415648119381

addr = base58.b58decode('3EVrDr2UpkLqRWza2vjyvboF5AXaqLsfD6')
addr.hex()
'058c7cf6077890b9a47744ce6326116bda102fd2b17dbe9a55'
int(addr.hex(), 16)
34830267579360635884357608966033687849564572378415648119381

You notice that it's more compact going from decimal, to hex, and to base58. 
You get more runes per "space"


Endianness - are we going backwards or are we going forwards when figuring out what the decimal value of this is?
smallest value bytes on the left is little endian, largest value on the left is big endian.

new concept *bytes* --> number buckets

8-bits --> 8  binary character in a row. is the amount of space we have in a byte

int('11111111', 2)
255

bytes.fromhex('ff')
b'\xff'
bytes.fromhex('ff00')
b'\xff\x00'
>>> bytes.fromhex('058c7cf6077890b9a47744ce6326116bda102fd2b17dbe9a55')
b'\x05\x8c|\xf6\x07x\x90\xb9\xa4wD\xcec&\x11k\xda\x10/\xd2\xb1}\xbe\x9aU'
>>> vals = bytes.fromhex('058c7cf6077890b9a47744ce6326116bda102fd2b17dbe9a55')
>>> [b for b in bytes(vals)]
[5, 140, 124, 246, 7, 120, 144, 185, 164, 119, 68, 206, 99, 38, 17, 107, 218, 16, 47, 210, 177, 125, 190, 154, 85]
>>> bb = [b for b in bytes(vals)]
>>> for num in bb:
...     print(num)
... 
5
140
124
246
7
120
144
185
164
119
68
206
99
38
17
107
218
16
47
210
177
125
190
154
85

Little Endian - the ::-1 reverses bb
>>> bb[::-1] - reverse the list
[85, 154, 190, 125, 177, 210, 47, 16, 218, 107, 17, 38, 99, 206, 68, 119, 164, 185, 144, 120, 7, 246, 124, 140, 5]

>>> for index, num in enumerate(bb[::-1]):
...     val = num * 256**index
...     sum += val
... 
>>> sum
34830267579360635884357608966033687849564572378415648119381

Big Endian
>>> sum
0
>>> for index, num in enumerate(bb):
...     val = num * 256**index
...     sum += val
... 
>>> sum
537347961933047319564711057038003994006750646414151631277061
>>> 


https://www.youtube.com/watch?v=bKVmhaRqsCg
